<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>docs.mllibprodest.interfaces API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>docs.mllibprodest.interfaces</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># ----------------------------------------------------------------------------------------------------
# Implementação das interfaces padrões para publicação de modelos no ML Worker.
#
# A função deste arquivo é a definição das interfaces padrões que devem ser utilizadas para fazer a
# publicação dos modelos que serão consumidos através do ML Worker.
#
# Uso: Distribua estas definições para os interessados em publicar os modelos.
#
# Fonte: https://realpython.com/python-interface/
# Baseado na seção: &#34;Using Abstract Method Declaration&#34;
# ----------------------------------------------------------------------------------------------------
import abc
from .shared_classes import CommonMethods
from math import ceil


class ModelPublicationInterfaceCLF(CommonMethods, metaclass=abc.ABCMeta):
    &#34;&#34;&#34;
    Interface para publicação de modelos de ML com a função de classificação.
    Leia a documentação dos métodos e implemente-os seguindo as recomendações de tipos de parâmetros e retorno.
    &#34;&#34;&#34;
    @classmethod
    def __subclasshook__(cls, subclass):
        return (hasattr(subclass, &#39;get_model_name&#39;) and
                callable(subclass.get_model_name) and
                hasattr(subclass, &#39;get_model_provider_name&#39;) and
                callable(subclass.get_model_provider_name) and
                hasattr(subclass, &#39;get_model_info&#39;) and
                callable(subclass.get_model_info) and
                hasattr(subclass, &#39;predict&#39;) and
                callable(subclass.predict) and
                hasattr(subclass, &#39;evaluate&#39;) and
                callable(subclass.evaluate) or
                NotImplemented)

    @abc.abstractmethod
    def get_model_name(self) -&gt; str:
        &#34;&#34;&#34;
        Obtém o nome do modelo que está em produção.

            @return: Nome do modelo que está em produção.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def get_model_provider_name(self) -&gt; str:
        &#34;&#34;&#34;
        Obtém o nome do provider que proverá o modelo que está em produção.

            @return: Nome do provider que proverá o modelo que está em produção.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def get_model_info(self) -&gt; dict:
        &#34;&#34;&#34;
        Obtém informações sobre o modelo que está em produção.

            @return: Dicionário com informações sobre o modelo.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def predict(self, dataset: list) -&gt; list:
        &#34;&#34;&#34;
        Faz predições utilizando o modelo que está em produção.

            @param dataset: Lista com os dados utilizados como features para realizar a predição.
            @return: Lista com os labels preditos.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def evaluate(self, data_features: list, data_targets: list) -&gt; dict:
        &#34;&#34;&#34;
        Calcula as métricas para avaliação do modelo.

            @param data_features: Lista com os dados utilizados como features para realizar o cálculo.
            @param data_targets: Lista com os targets correspondentes às features para realizar o cálculo.
                                 É imprescindível que a posição de cada elemento da lista de features corresponda à
                                 resposta esperada para cada elemento da lista de targets.
            @return: Dicionário com as métricas calculadas.
        &#34;&#34;&#34;
        raise NotImplementedError


class ModelPublicationInterfaceRETRAIN(CommonMethods, metaclass=abc.ABCMeta):
    &#34;&#34;&#34;
    Interface para publicação de modelos de ML com a função de retreino.
    Leia a documentação dos métodos e implemente-os seguindo as recomendações de tipos de parâmetros e retorno.
    &#34;&#34;&#34;
    @classmethod
    def __subclasshook__(cls, subclass):
        return (hasattr(subclass, &#39;get_model_name&#39;) and
                callable(subclass.get_model_name) and
                hasattr(subclass, &#39;get_model_provider_name&#39;) and
                callable(subclass.get_model_provider_name) and
                hasattr(subclass, &#39;get_experiment_name&#39;) and
                callable(subclass.get_experiment_name) and
                hasattr(subclass, &#39;get_dataset_provider_name&#39;) and
                callable(subclass.get_dataset_provider_name) and
                hasattr(subclass, &#39;evaluate&#39;) and
                callable(subclass.evaluate) and
                hasattr(subclass, &#39;retrain&#39;) and
                callable(subclass.retrain) or
                NotImplemented)

    @abc.abstractmethod
    def get_model_name(self) -&gt; str:
        &#34;&#34;&#34;
        Obtém o nome do modelo que está em produção.

            @return: Nome do modelo que está em produção.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def get_model_provider_name(self) -&gt; str:
        &#34;&#34;&#34;
        Obtém o nome do provider que proverá o modelo que está em produção.

            @return: Nome do provider que proverá o modelo que está em produção.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def get_experiment_name(self) -&gt; str:
        &#34;&#34;&#34;
        Obtém o nome do experimento que será utilizado em produção.

            @return: Nome do experimento que será utilizado em produção.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def get_dataset_provider_name(self) -&gt; str:
        &#34;&#34;&#34;
        Obtém o nome do provider do dataset usado pelo modelo que está em produção.

            @return: Nome do provider do dataset usado pelo modelo que está em produção.
        &#34;&#34;&#34;
        raise NotImplementedError

    @staticmethod
    def generate_batch_indices(dataset_size: int, batch_size: int = 100000):
        &#34;&#34;&#34;
        Gera indices para auxiliar na predição de registros em lote. Esta função gera uma lista contendo tuplas de
        indices (inicio, fim) que pode ser percorrida em um laço para obtenção dos índices para fazer o fatiamento do
        dataset e auxiliar a predição em lote. Ex. de lista gerada: [(0, 5), (5, 10), (10, 15), ...].

            @param dataset_size: Tamanho do dataset que será predito.
            @param batch_size: Tamanho do lote.
            @return: Lista contendo tuplas de indices (inicio, fim).
        &#34;&#34;&#34;
        if dataset_size &lt;= 0:
            return []

        tamanho_minimo_lote = 10000
        indices = []  # Guarda as tuplas de indices que serão utilizadas para fatiar o dataset

        if batch_size &gt;= tamanho_minimo_lote:
            ind_inicial = 0
            ind_final = batch_size if batch_size &lt; dataset_size else dataset_size
            qtd_lotes = ceil(dataset_size / batch_size)

            for i in range(qtd_lotes):
                indices.append((ind_inicial, ind_final))
                ind_inicial = ind_final

                # Evita que o último indice seja maior que o tamanho do dataset
                if ind_inicial + batch_size &lt; dataset_size:
                    ind_final += batch_size
                else:
                    ind_final = dataset_size
        else:
            indices.append((0, dataset_size))

        return indices

    @abc.abstractmethod
    def evaluate(self, model, datasets: dict, baseline_metrics: dict, training_params: dict,
                 artifacts_path: str = &#34;temp_area&#34;, batch_size: int = 100000) -&gt; (bool, dict):
        &#34;&#34;&#34;
        Faz a avaliação do modelo que está em produção e compara com as métricas de baseline definidas para ele.

            @param model: Modelo que está em produção.
            @param datasets: Dicionário com os datasets que serão utilizados na avaliação. Dica: Colocar o tipo de
                             dataset (features, targets, etc.) como chave e o dataset em si como valor.
            @param baseline_metrics: Dicionário com as métricas do modelo em produção que servirão de baseline para a
                                     avaliação.
            @param training_params: Dicionário com os parâmetros utilizados no treinamento do modelo que está em
                                    produção.
            @param artifacts_path: Caminho local para a obtenção dos artefatos do modelo. Para facilitar, utilize o
                                   valor padrão &#39;temp_area&#39;.
            @param batch_size: Tamanho do lote. Utilizado para datasets grandes, para não faltar memória ao realizar
                               as predições.
            @return: Tupla contendo: True se o modelo passou na avaliação das métricas ou False, caso contrário, e
                                     um dicionário com informações adicionais sobre a avaliação.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def retrain(self, production_model_name: str, production_params: dict, experiment_name: str, datasets: dict,
                reasons: dict):
        &#34;&#34;&#34;
        Faz o retreinamento do modelo de forma automatizada.

            @param production_model_name: Nome do modelo que está em produção para obtenção dos parâmetros para o
                                          retreino, se necessário.
            @param production_params: Dicionário com os parâmetros que foram utilizados no treinamento do modelo que
                                      está em produção.
            @param experiment_name: Nome do experimento para persistir o modelo retreinado.
            @param datasets: Dicionário com os datasets que serão utilizados no retreino. Dica: Colocar o tipo de
                             dataset (features, targets, etc.) como chave e o dataset em si como valor.
            @param reasons: Dicionário com o(s) motivo(s) para realização do retreinamento e/ou informações adicionais.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="docs.mllibprodest.interfaces.ModelPublicationInterfaceCLF"><code class="flex name class">
<span>class <span class="ident">ModelPublicationInterfaceCLF</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface para publicação de modelos de ML com a função de classificação.
Leia a documentação dos métodos e implemente-os seguindo as recomendações de tipos de parâmetros e retorno.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModelPublicationInterfaceCLF(CommonMethods, metaclass=abc.ABCMeta):
    &#34;&#34;&#34;
    Interface para publicação de modelos de ML com a função de classificação.
    Leia a documentação dos métodos e implemente-os seguindo as recomendações de tipos de parâmetros e retorno.
    &#34;&#34;&#34;
    @classmethod
    def __subclasshook__(cls, subclass):
        return (hasattr(subclass, &#39;get_model_name&#39;) and
                callable(subclass.get_model_name) and
                hasattr(subclass, &#39;get_model_provider_name&#39;) and
                callable(subclass.get_model_provider_name) and
                hasattr(subclass, &#39;get_model_info&#39;) and
                callable(subclass.get_model_info) and
                hasattr(subclass, &#39;predict&#39;) and
                callable(subclass.predict) and
                hasattr(subclass, &#39;evaluate&#39;) and
                callable(subclass.evaluate) or
                NotImplemented)

    @abc.abstractmethod
    def get_model_name(self) -&gt; str:
        &#34;&#34;&#34;
        Obtém o nome do modelo que está em produção.

            @return: Nome do modelo que está em produção.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def get_model_provider_name(self) -&gt; str:
        &#34;&#34;&#34;
        Obtém o nome do provider que proverá o modelo que está em produção.

            @return: Nome do provider que proverá o modelo que está em produção.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def get_model_info(self) -&gt; dict:
        &#34;&#34;&#34;
        Obtém informações sobre o modelo que está em produção.

            @return: Dicionário com informações sobre o modelo.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def predict(self, dataset: list) -&gt; list:
        &#34;&#34;&#34;
        Faz predições utilizando o modelo que está em produção.

            @param dataset: Lista com os dados utilizados como features para realizar a predição.
            @return: Lista com os labels preditos.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def evaluate(self, data_features: list, data_targets: list) -&gt; dict:
        &#34;&#34;&#34;
        Calcula as métricas para avaliação do modelo.

            @param data_features: Lista com os dados utilizados como features para realizar o cálculo.
            @param data_targets: Lista com os targets correspondentes às features para realizar o cálculo.
                                 É imprescindível que a posição de cada elemento da lista de features corresponda à
                                 resposta esperada para cada elemento da lista de targets.
            @return: Dicionário com as métricas calculadas.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="docs.mllibprodest.shared_classes.CommonMethods" href="shared_classes.html#docs.mllibprodest.shared_classes.CommonMethods">CommonMethods</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="docs.mllibprodest.interfaces.ModelPublicationInterfaceCLF.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, data_features: list, data_targets: list) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Calcula as métricas para avaliação do modelo.</p>
<pre><code>@param data_features: Lista com os dados utilizados como features para realizar o cálculo.
@param data_targets: Lista com os targets correspondentes às features para realizar o cálculo.
                     É imprescindível que a posição de cada elemento da lista de features corresponda à
                     resposta esperada para cada elemento da lista de targets.
@return: Dicionário com as métricas calculadas.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def evaluate(self, data_features: list, data_targets: list) -&gt; dict:
    &#34;&#34;&#34;
    Calcula as métricas para avaliação do modelo.

        @param data_features: Lista com os dados utilizados como features para realizar o cálculo.
        @param data_targets: Lista com os targets correspondentes às features para realizar o cálculo.
                             É imprescindível que a posição de cada elemento da lista de features corresponda à
                             resposta esperada para cada elemento da lista de targets.
        @return: Dicionário com as métricas calculadas.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="docs.mllibprodest.interfaces.ModelPublicationInterfaceCLF.get_model_info"><code class="name flex">
<span>def <span class="ident">get_model_info</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Obtém informações sobre o modelo que está em produção.</p>
<pre><code>@return: Dicionário com informações sobre o modelo.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def get_model_info(self) -&gt; dict:
    &#34;&#34;&#34;
    Obtém informações sobre o modelo que está em produção.

        @return: Dicionário com informações sobre o modelo.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="docs.mllibprodest.interfaces.ModelPublicationInterfaceCLF.get_model_name"><code class="name flex">
<span>def <span class="ident">get_model_name</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Obtém o nome do modelo que está em produção.</p>
<pre><code>@return: Nome do modelo que está em produção.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def get_model_name(self) -&gt; str:
    &#34;&#34;&#34;
    Obtém o nome do modelo que está em produção.

        @return: Nome do modelo que está em produção.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="docs.mllibprodest.interfaces.ModelPublicationInterfaceCLF.get_model_provider_name"><code class="name flex">
<span>def <span class="ident">get_model_provider_name</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Obtém o nome do provider que proverá o modelo que está em produção.</p>
<pre><code>@return: Nome do provider que proverá o modelo que está em produção.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def get_model_provider_name(self) -&gt; str:
    &#34;&#34;&#34;
    Obtém o nome do provider que proverá o modelo que está em produção.

        @return: Nome do provider que proverá o modelo que está em produção.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="docs.mllibprodest.interfaces.ModelPublicationInterfaceCLF.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, dataset: list) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Faz predições utilizando o modelo que está em produção.</p>
<pre><code>@param dataset: Lista com os dados utilizados como features para realizar a predição.
@return: Lista com os labels preditos.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def predict(self, dataset: list) -&gt; list:
    &#34;&#34;&#34;
    Faz predições utilizando o modelo que está em produção.

        @param dataset: Lista com os dados utilizados como features para realizar a predição.
        @return: Lista com os labels preditos.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="docs.mllibprodest.shared_classes.CommonMethods" href="shared_classes.html#docs.mllibprodest.shared_classes.CommonMethods">CommonMethods</a></b></code>:
<ul class="hlist">
<li><code><a title="docs.mllibprodest.shared_classes.CommonMethods.convert_artifact_to_object" href="shared_classes.html#docs.mllibprodest.shared_classes.CommonMethods.convert_artifact_to_object">convert_artifact_to_object</a></code></li>
<li><code><a title="docs.mllibprodest.shared_classes.CommonMethods.convert_artifact_to_pickle" href="shared_classes.html#docs.mllibprodest.shared_classes.CommonMethods.convert_artifact_to_pickle">convert_artifact_to_pickle</a></code></li>
<li><code><a title="docs.mllibprodest.shared_classes.CommonMethods.load_datasets" href="shared_classes.html#docs.mllibprodest.shared_classes.CommonMethods.load_datasets">load_datasets</a></code></li>
<li><code><a title="docs.mllibprodest.shared_classes.CommonMethods.load_model" href="shared_classes.html#docs.mllibprodest.shared_classes.CommonMethods.load_model">load_model</a></code></li>
<li><code><a title="docs.mllibprodest.shared_classes.CommonMethods.load_production_baseline" href="shared_classes.html#docs.mllibprodest.shared_classes.CommonMethods.load_production_baseline">load_production_baseline</a></code></li>
<li><code><a title="docs.mllibprodest.shared_classes.CommonMethods.load_production_datasets_names" href="shared_classes.html#docs.mllibprodest.shared_classes.CommonMethods.load_production_datasets_names">load_production_datasets_names</a></code></li>
<li><code><a title="docs.mllibprodest.shared_classes.CommonMethods.load_production_params" href="shared_classes.html#docs.mllibprodest.shared_classes.CommonMethods.load_production_params">load_production_params</a></code></li>
<li><code><a title="docs.mllibprodest.shared_classes.CommonMethods.make_log" href="shared_classes.html#docs.mllibprodest.shared_classes.CommonMethods.make_log">make_log</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="docs.mllibprodest.interfaces.ModelPublicationInterfaceRETRAIN"><code class="flex name class">
<span>class <span class="ident">ModelPublicationInterfaceRETRAIN</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface para publicação de modelos de ML com a função de retreino.
Leia a documentação dos métodos e implemente-os seguindo as recomendações de tipos de parâmetros e retorno.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModelPublicationInterfaceRETRAIN(CommonMethods, metaclass=abc.ABCMeta):
    &#34;&#34;&#34;
    Interface para publicação de modelos de ML com a função de retreino.
    Leia a documentação dos métodos e implemente-os seguindo as recomendações de tipos de parâmetros e retorno.
    &#34;&#34;&#34;
    @classmethod
    def __subclasshook__(cls, subclass):
        return (hasattr(subclass, &#39;get_model_name&#39;) and
                callable(subclass.get_model_name) and
                hasattr(subclass, &#39;get_model_provider_name&#39;) and
                callable(subclass.get_model_provider_name) and
                hasattr(subclass, &#39;get_experiment_name&#39;) and
                callable(subclass.get_experiment_name) and
                hasattr(subclass, &#39;get_dataset_provider_name&#39;) and
                callable(subclass.get_dataset_provider_name) and
                hasattr(subclass, &#39;evaluate&#39;) and
                callable(subclass.evaluate) and
                hasattr(subclass, &#39;retrain&#39;) and
                callable(subclass.retrain) or
                NotImplemented)

    @abc.abstractmethod
    def get_model_name(self) -&gt; str:
        &#34;&#34;&#34;
        Obtém o nome do modelo que está em produção.

            @return: Nome do modelo que está em produção.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def get_model_provider_name(self) -&gt; str:
        &#34;&#34;&#34;
        Obtém o nome do provider que proverá o modelo que está em produção.

            @return: Nome do provider que proverá o modelo que está em produção.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def get_experiment_name(self) -&gt; str:
        &#34;&#34;&#34;
        Obtém o nome do experimento que será utilizado em produção.

            @return: Nome do experimento que será utilizado em produção.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def get_dataset_provider_name(self) -&gt; str:
        &#34;&#34;&#34;
        Obtém o nome do provider do dataset usado pelo modelo que está em produção.

            @return: Nome do provider do dataset usado pelo modelo que está em produção.
        &#34;&#34;&#34;
        raise NotImplementedError

    @staticmethod
    def generate_batch_indices(dataset_size: int, batch_size: int = 100000):
        &#34;&#34;&#34;
        Gera indices para auxiliar na predição de registros em lote. Esta função gera uma lista contendo tuplas de
        indices (inicio, fim) que pode ser percorrida em um laço para obtenção dos índices para fazer o fatiamento do
        dataset e auxiliar a predição em lote. Ex. de lista gerada: [(0, 5), (5, 10), (10, 15), ...].

            @param dataset_size: Tamanho do dataset que será predito.
            @param batch_size: Tamanho do lote.
            @return: Lista contendo tuplas de indices (inicio, fim).
        &#34;&#34;&#34;
        if dataset_size &lt;= 0:
            return []

        tamanho_minimo_lote = 10000
        indices = []  # Guarda as tuplas de indices que serão utilizadas para fatiar o dataset

        if batch_size &gt;= tamanho_minimo_lote:
            ind_inicial = 0
            ind_final = batch_size if batch_size &lt; dataset_size else dataset_size
            qtd_lotes = ceil(dataset_size / batch_size)

            for i in range(qtd_lotes):
                indices.append((ind_inicial, ind_final))
                ind_inicial = ind_final

                # Evita que o último indice seja maior que o tamanho do dataset
                if ind_inicial + batch_size &lt; dataset_size:
                    ind_final += batch_size
                else:
                    ind_final = dataset_size
        else:
            indices.append((0, dataset_size))

        return indices

    @abc.abstractmethod
    def evaluate(self, model, datasets: dict, baseline_metrics: dict, training_params: dict,
                 artifacts_path: str = &#34;temp_area&#34;, batch_size: int = 100000) -&gt; (bool, dict):
        &#34;&#34;&#34;
        Faz a avaliação do modelo que está em produção e compara com as métricas de baseline definidas para ele.

            @param model: Modelo que está em produção.
            @param datasets: Dicionário com os datasets que serão utilizados na avaliação. Dica: Colocar o tipo de
                             dataset (features, targets, etc.) como chave e o dataset em si como valor.
            @param baseline_metrics: Dicionário com as métricas do modelo em produção que servirão de baseline para a
                                     avaliação.
            @param training_params: Dicionário com os parâmetros utilizados no treinamento do modelo que está em
                                    produção.
            @param artifacts_path: Caminho local para a obtenção dos artefatos do modelo. Para facilitar, utilize o
                                   valor padrão &#39;temp_area&#39;.
            @param batch_size: Tamanho do lote. Utilizado para datasets grandes, para não faltar memória ao realizar
                               as predições.
            @return: Tupla contendo: True se o modelo passou na avaliação das métricas ou False, caso contrário, e
                                     um dicionário com informações adicionais sobre a avaliação.
        &#34;&#34;&#34;
        raise NotImplementedError

    @abc.abstractmethod
    def retrain(self, production_model_name: str, production_params: dict, experiment_name: str, datasets: dict,
                reasons: dict):
        &#34;&#34;&#34;
        Faz o retreinamento do modelo de forma automatizada.

            @param production_model_name: Nome do modelo que está em produção para obtenção dos parâmetros para o
                                          retreino, se necessário.
            @param production_params: Dicionário com os parâmetros que foram utilizados no treinamento do modelo que
                                      está em produção.
            @param experiment_name: Nome do experimento para persistir o modelo retreinado.
            @param datasets: Dicionário com os datasets que serão utilizados no retreino. Dica: Colocar o tipo de
                             dataset (features, targets, etc.) como chave e o dataset em si como valor.
            @param reasons: Dicionário com o(s) motivo(s) para realização do retreinamento e/ou informações adicionais.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="docs.mllibprodest.shared_classes.CommonMethods" href="shared_classes.html#docs.mllibprodest.shared_classes.CommonMethods">CommonMethods</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="docs.mllibprodest.interfaces.ModelPublicationInterfaceRETRAIN.generate_batch_indices"><code class="name flex">
<span>def <span class="ident">generate_batch_indices</span></span>(<span>dataset_size: int, batch_size: int = 100000)</span>
</code></dt>
<dd>
<div class="desc"><p>Gera indices para auxiliar na predição de registros em lote. Esta função gera uma lista contendo tuplas de
indices (inicio, fim) que pode ser percorrida em um laço para obtenção dos índices para fazer o fatiamento do
dataset e auxiliar a predição em lote. Ex. de lista gerada: [(0, 5), (5, 10), (10, 15), &hellip;].</p>
<pre><code>@param dataset_size: Tamanho do dataset que será predito.
@param batch_size: Tamanho do lote.
@return: Lista contendo tuplas de indices (inicio, fim).
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def generate_batch_indices(dataset_size: int, batch_size: int = 100000):
    &#34;&#34;&#34;
    Gera indices para auxiliar na predição de registros em lote. Esta função gera uma lista contendo tuplas de
    indices (inicio, fim) que pode ser percorrida em um laço para obtenção dos índices para fazer o fatiamento do
    dataset e auxiliar a predição em lote. Ex. de lista gerada: [(0, 5), (5, 10), (10, 15), ...].

        @param dataset_size: Tamanho do dataset que será predito.
        @param batch_size: Tamanho do lote.
        @return: Lista contendo tuplas de indices (inicio, fim).
    &#34;&#34;&#34;
    if dataset_size &lt;= 0:
        return []

    tamanho_minimo_lote = 10000
    indices = []  # Guarda as tuplas de indices que serão utilizadas para fatiar o dataset

    if batch_size &gt;= tamanho_minimo_lote:
        ind_inicial = 0
        ind_final = batch_size if batch_size &lt; dataset_size else dataset_size
        qtd_lotes = ceil(dataset_size / batch_size)

        for i in range(qtd_lotes):
            indices.append((ind_inicial, ind_final))
            ind_inicial = ind_final

            # Evita que o último indice seja maior que o tamanho do dataset
            if ind_inicial + batch_size &lt; dataset_size:
                ind_final += batch_size
            else:
                ind_final = dataset_size
    else:
        indices.append((0, dataset_size))

    return indices</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="docs.mllibprodest.interfaces.ModelPublicationInterfaceRETRAIN.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, model, datasets: dict, baseline_metrics: dict, training_params: dict, artifacts_path: str = 'temp_area', batch_size: int = 100000) ‑> (<class 'bool'>, <class 'dict'>)</span>
</code></dt>
<dd>
<div class="desc"><p>Faz a avaliação do modelo que está em produção e compara com as métricas de baseline definidas para ele.</p>
<pre><code>@param model: Modelo que está em produção.
@param datasets: Dicionário com os datasets que serão utilizados na avaliação. Dica: Colocar o tipo de
                 dataset (features, targets, etc.) como chave e o dataset em si como valor.
@param baseline_metrics: Dicionário com as métricas do modelo em produção que servirão de baseline para a
                         avaliação.
@param training_params: Dicionário com os parâmetros utilizados no treinamento do modelo que está em
                        produção.
@param artifacts_path: Caminho local para a obtenção dos artefatos do modelo. Para facilitar, utilize o
                       valor padrão 'temp_area'.
@param batch_size: Tamanho do lote. Utilizado para datasets grandes, para não faltar memória ao realizar
                   as predições.
@return: Tupla contendo: True se o modelo passou na avaliação das métricas ou False, caso contrário, e
                         um dicionário com informações adicionais sobre a avaliação.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def evaluate(self, model, datasets: dict, baseline_metrics: dict, training_params: dict,
             artifacts_path: str = &#34;temp_area&#34;, batch_size: int = 100000) -&gt; (bool, dict):
    &#34;&#34;&#34;
    Faz a avaliação do modelo que está em produção e compara com as métricas de baseline definidas para ele.

        @param model: Modelo que está em produção.
        @param datasets: Dicionário com os datasets que serão utilizados na avaliação. Dica: Colocar o tipo de
                         dataset (features, targets, etc.) como chave e o dataset em si como valor.
        @param baseline_metrics: Dicionário com as métricas do modelo em produção que servirão de baseline para a
                                 avaliação.
        @param training_params: Dicionário com os parâmetros utilizados no treinamento do modelo que está em
                                produção.
        @param artifacts_path: Caminho local para a obtenção dos artefatos do modelo. Para facilitar, utilize o
                               valor padrão &#39;temp_area&#39;.
        @param batch_size: Tamanho do lote. Utilizado para datasets grandes, para não faltar memória ao realizar
                           as predições.
        @return: Tupla contendo: True se o modelo passou na avaliação das métricas ou False, caso contrário, e
                                 um dicionário com informações adicionais sobre a avaliação.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="docs.mllibprodest.interfaces.ModelPublicationInterfaceRETRAIN.get_dataset_provider_name"><code class="name flex">
<span>def <span class="ident">get_dataset_provider_name</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Obtém o nome do provider do dataset usado pelo modelo que está em produção.</p>
<pre><code>@return: Nome do provider do dataset usado pelo modelo que está em produção.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def get_dataset_provider_name(self) -&gt; str:
    &#34;&#34;&#34;
    Obtém o nome do provider do dataset usado pelo modelo que está em produção.

        @return: Nome do provider do dataset usado pelo modelo que está em produção.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="docs.mllibprodest.interfaces.ModelPublicationInterfaceRETRAIN.get_experiment_name"><code class="name flex">
<span>def <span class="ident">get_experiment_name</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Obtém o nome do experimento que será utilizado em produção.</p>
<pre><code>@return: Nome do experimento que será utilizado em produção.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def get_experiment_name(self) -&gt; str:
    &#34;&#34;&#34;
    Obtém o nome do experimento que será utilizado em produção.

        @return: Nome do experimento que será utilizado em produção.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="docs.mllibprodest.interfaces.ModelPublicationInterfaceRETRAIN.get_model_name"><code class="name flex">
<span>def <span class="ident">get_model_name</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Obtém o nome do modelo que está em produção.</p>
<pre><code>@return: Nome do modelo que está em produção.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def get_model_name(self) -&gt; str:
    &#34;&#34;&#34;
    Obtém o nome do modelo que está em produção.

        @return: Nome do modelo que está em produção.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="docs.mllibprodest.interfaces.ModelPublicationInterfaceRETRAIN.get_model_provider_name"><code class="name flex">
<span>def <span class="ident">get_model_provider_name</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Obtém o nome do provider que proverá o modelo que está em produção.</p>
<pre><code>@return: Nome do provider que proverá o modelo que está em produção.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def get_model_provider_name(self) -&gt; str:
    &#34;&#34;&#34;
    Obtém o nome do provider que proverá o modelo que está em produção.

        @return: Nome do provider que proverá o modelo que está em produção.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="docs.mllibprodest.interfaces.ModelPublicationInterfaceRETRAIN.retrain"><code class="name flex">
<span>def <span class="ident">retrain</span></span>(<span>self, production_model_name: str, production_params: dict, experiment_name: str, datasets: dict, reasons: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Faz o retreinamento do modelo de forma automatizada.</p>
<pre><code>@param production_model_name: Nome do modelo que está em produção para obtenção dos parâmetros para o
                              retreino, se necessário.
@param production_params: Dicionário com os parâmetros que foram utilizados no treinamento do modelo que
                          está em produção.
@param experiment_name: Nome do experimento para persistir o modelo retreinado.
@param datasets: Dicionário com os datasets que serão utilizados no retreino. Dica: Colocar o tipo de
                 dataset (features, targets, etc.) como chave e o dataset em si como valor.
@param reasons: Dicionário com o(s) motivo(s) para realização do retreinamento e/ou informações adicionais.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def retrain(self, production_model_name: str, production_params: dict, experiment_name: str, datasets: dict,
            reasons: dict):
    &#34;&#34;&#34;
    Faz o retreinamento do modelo de forma automatizada.

        @param production_model_name: Nome do modelo que está em produção para obtenção dos parâmetros para o
                                      retreino, se necessário.
        @param production_params: Dicionário com os parâmetros que foram utilizados no treinamento do modelo que
                                  está em produção.
        @param experiment_name: Nome do experimento para persistir o modelo retreinado.
        @param datasets: Dicionário com os datasets que serão utilizados no retreino. Dica: Colocar o tipo de
                         dataset (features, targets, etc.) como chave e o dataset em si como valor.
        @param reasons: Dicionário com o(s) motivo(s) para realização do retreinamento e/ou informações adicionais.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="docs.mllibprodest.shared_classes.CommonMethods" href="shared_classes.html#docs.mllibprodest.shared_classes.CommonMethods">CommonMethods</a></b></code>:
<ul class="hlist">
<li><code><a title="docs.mllibprodest.shared_classes.CommonMethods.convert_artifact_to_object" href="shared_classes.html#docs.mllibprodest.shared_classes.CommonMethods.convert_artifact_to_object">convert_artifact_to_object</a></code></li>
<li><code><a title="docs.mllibprodest.shared_classes.CommonMethods.convert_artifact_to_pickle" href="shared_classes.html#docs.mllibprodest.shared_classes.CommonMethods.convert_artifact_to_pickle">convert_artifact_to_pickle</a></code></li>
<li><code><a title="docs.mllibprodest.shared_classes.CommonMethods.load_datasets" href="shared_classes.html#docs.mllibprodest.shared_classes.CommonMethods.load_datasets">load_datasets</a></code></li>
<li><code><a title="docs.mllibprodest.shared_classes.CommonMethods.load_model" href="shared_classes.html#docs.mllibprodest.shared_classes.CommonMethods.load_model">load_model</a></code></li>
<li><code><a title="docs.mllibprodest.shared_classes.CommonMethods.load_production_baseline" href="shared_classes.html#docs.mllibprodest.shared_classes.CommonMethods.load_production_baseline">load_production_baseline</a></code></li>
<li><code><a title="docs.mllibprodest.shared_classes.CommonMethods.load_production_datasets_names" href="shared_classes.html#docs.mllibprodest.shared_classes.CommonMethods.load_production_datasets_names">load_production_datasets_names</a></code></li>
<li><code><a title="docs.mllibprodest.shared_classes.CommonMethods.load_production_params" href="shared_classes.html#docs.mllibprodest.shared_classes.CommonMethods.load_production_params">load_production_params</a></code></li>
<li><code><a title="docs.mllibprodest.shared_classes.CommonMethods.make_log" href="shared_classes.html#docs.mllibprodest.shared_classes.CommonMethods.make_log">make_log</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="docs.mllibprodest" href="index.html">docs.mllibprodest</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="docs.mllibprodest.interfaces.ModelPublicationInterfaceCLF" href="#docs.mllibprodest.interfaces.ModelPublicationInterfaceCLF">ModelPublicationInterfaceCLF</a></code></h4>
<ul class="">
<li><code><a title="docs.mllibprodest.interfaces.ModelPublicationInterfaceCLF.evaluate" href="#docs.mllibprodest.interfaces.ModelPublicationInterfaceCLF.evaluate">evaluate</a></code></li>
<li><code><a title="docs.mllibprodest.interfaces.ModelPublicationInterfaceCLF.get_model_info" href="#docs.mllibprodest.interfaces.ModelPublicationInterfaceCLF.get_model_info">get_model_info</a></code></li>
<li><code><a title="docs.mllibprodest.interfaces.ModelPublicationInterfaceCLF.get_model_name" href="#docs.mllibprodest.interfaces.ModelPublicationInterfaceCLF.get_model_name">get_model_name</a></code></li>
<li><code><a title="docs.mllibprodest.interfaces.ModelPublicationInterfaceCLF.get_model_provider_name" href="#docs.mllibprodest.interfaces.ModelPublicationInterfaceCLF.get_model_provider_name">get_model_provider_name</a></code></li>
<li><code><a title="docs.mllibprodest.interfaces.ModelPublicationInterfaceCLF.predict" href="#docs.mllibprodest.interfaces.ModelPublicationInterfaceCLF.predict">predict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="docs.mllibprodest.interfaces.ModelPublicationInterfaceRETRAIN" href="#docs.mllibprodest.interfaces.ModelPublicationInterfaceRETRAIN">ModelPublicationInterfaceRETRAIN</a></code></h4>
<ul class="">
<li><code><a title="docs.mllibprodest.interfaces.ModelPublicationInterfaceRETRAIN.evaluate" href="#docs.mllibprodest.interfaces.ModelPublicationInterfaceRETRAIN.evaluate">evaluate</a></code></li>
<li><code><a title="docs.mllibprodest.interfaces.ModelPublicationInterfaceRETRAIN.generate_batch_indices" href="#docs.mllibprodest.interfaces.ModelPublicationInterfaceRETRAIN.generate_batch_indices">generate_batch_indices</a></code></li>
<li><code><a title="docs.mllibprodest.interfaces.ModelPublicationInterfaceRETRAIN.get_dataset_provider_name" href="#docs.mllibprodest.interfaces.ModelPublicationInterfaceRETRAIN.get_dataset_provider_name">get_dataset_provider_name</a></code></li>
<li><code><a title="docs.mllibprodest.interfaces.ModelPublicationInterfaceRETRAIN.get_experiment_name" href="#docs.mllibprodest.interfaces.ModelPublicationInterfaceRETRAIN.get_experiment_name">get_experiment_name</a></code></li>
<li><code><a title="docs.mllibprodest.interfaces.ModelPublicationInterfaceRETRAIN.get_model_name" href="#docs.mllibprodest.interfaces.ModelPublicationInterfaceRETRAIN.get_model_name">get_model_name</a></code></li>
<li><code><a title="docs.mllibprodest.interfaces.ModelPublicationInterfaceRETRAIN.get_model_provider_name" href="#docs.mllibprodest.interfaces.ModelPublicationInterfaceRETRAIN.get_model_provider_name">get_model_provider_name</a></code></li>
<li><code><a title="docs.mllibprodest.interfaces.ModelPublicationInterfaceRETRAIN.retrain" href="#docs.mllibprodest.interfaces.ModelPublicationInterfaceRETRAIN.retrain">retrain</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>